import { mcpConnectorConfig } from '@stackone/mcp-config-types';
import { z } from 'zod';

/**
 * MCP Creator - A connector that helps users create their own MCP servers
 * Incorporates patterns and best practices from Claude agents working on GitHub issues
 */

interface MCPConnectorTemplate {
  name: string;
  key: string;
  description: string;
  tools: Array<{
    name: string;
    description: string;
    schema: Record<string, unknown>;
    implementation?: string;
  }>;
  credentials: Record<string, unknown>;
  setup: Record<string, unknown>;
}

interface CodeAnalysisResult {
  patterns: string[];
  imports: string[];
  interfaces: string[];
  recommendations: string[];
}

// biome-ignore lint/complexity/noStaticOnlyClass: Helper functions organized for clarity
class MCPCreatorHelper {
  /**
   * Generates a basic MCP connector template based on user requirements
   */
  static generateConnectorTemplate(
    name: string,
    description: string,
    apiType: string,
    tools: string[]
  ): MCPConnectorTemplate {
    const key = name.toLowerCase().replace(/[^a-z0-9]/g, '-');

    const credentialsMap: Record<string, Record<string, string>> = {
      'rest-api': {
        apiKey: 'z.string().describe("API Key for authentication")',
        baseUrl: 'z.string().optional().describe("Base URL for the API (optional)")',
      },
      oauth: {
        clientId: 'z.string().describe("OAuth Client ID")',
        clientSecret: 'z.string().describe("OAuth Client Secret")',
        redirectUri: 'z.string().describe("OAuth Redirect URI")',
      },
      'basic-auth': {
        username: 'z.string().describe("Username for basic authentication")',
        password: 'z.string().describe("Password for basic authentication")',
      },
      none: {},
    };

    const toolTemplates = tools.map((toolName) => ({
      name: toolName.toLowerCase().replace(/\s+/g, '_'),
      description: `${toolName} - Generated tool for ${name} integration`,
      schema: {
        id: 'z.string().describe("Unique identifier")',
        data: 'z.object({}).describe("Tool-specific data")',
      },
      implementation: MCPCreatorHelper.generateToolImplementation(toolName, apiType),
    }));

    return {
      name,
      key,
      description,
      tools: toolTemplates,
      credentials: credentialsMap[apiType] || credentialsMap['rest-api'],
      setup: {
        environment:
          'z.enum(["development", "staging", "production"]).default("production").describe("Environment to connect to")',
      },
    };
  }

  /**
   * Generates tool implementation code following Claude agent patterns
   */
  static generateToolImplementation(toolName: string, _apiType: string): string {
    const toolKey = toolName.toUpperCase().replace(/\s+/g, '_');
    const toolFunction = toolName.toLowerCase().replace(/\s+/g, '_');

    return `    ${toolKey}: tool({
      name: '${toolFunction}',
      description: '${toolName} - Implement your specific logic here',
      schema: z.object({
        id: z.string().describe('Unique identifier'),
        // Add your specific parameters here
      }),
      handler: async (args, context) => {
        try {
          const credentials = await context.getCredentials();
          
          // Implement your API call logic here
          const response = await fetch(\`\${credentials.baseUrl || 'https://api.example.com'}/endpoint\`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': \`Bearer \${credentials.apiKey}\`,
            },
            body: JSON.stringify(args),
          });

          if (!response.ok) {
            throw new Error(\`API request failed: \${response.status} \${response.statusText}\`);
          }

          const data = await response.json();
          return JSON.stringify(data, null, 2);
        } catch (error) {
          return \`Failed to ${toolName.toLowerCase()}: \${error instanceof Error ? error.message : String(error)}\`;
        }
      },
    }),`;
  }

  /**
   * Generates a complete MCP connector file following repository patterns
   */
  static generateConnectorFile(template: MCPConnectorTemplate): string {
    const credentialsCode = Object.entries(template.credentials)
      .map(([key, value]) => `    ${key}: ${value}`)
      .join(',\n');

    const setupCode = Object.entries(template.setup)
      .map(([key, value]) => `    ${key}: ${value}`)
      .join(',\n');

    const toolsCode = template.tools
      .map((tool) => tool.implementation || '')
      .join('\n\n');

    return `import { mcpConnectorConfig } from '@stackone/mcp-config-types';
import { z } from 'zod';

/**
 * ${template.name} Connector
 * ${template.description}
 * 
 * Generated by MCP Creator - customize as needed
 */

export const ${template.name.replace(/[^a-zA-Z0-9]/g, '')}ConnectorConfig = mcpConnectorConfig({
  name: '${template.name}',
  key: '${template.key}',
  version: '1.0.0',
  logo: 'https://stackone-logos.com/api/${template.key}/filled/svg',
  credentials: z.object({
${credentialsCode}
  }),
  setup: z.object({
${setupCode}
  }),
  examplePrompt: 'Use the ${template.name} connector to interact with the API and perform common operations.',
  tools: (tool) => ({
${toolsCode}
  }),
});
`;
  }

  /**
   * Generates test file following repository testing patterns
   */
  static generateTestFile(template: MCPConnectorTemplate): string {
    const connectorName = template.name.replace(/[^a-zA-Z0-9]/g, '');
    const testCases = template.tools
      .map((tool) => {
        const toolKey = tool.name.toUpperCase();
        return `  describe('.${toolKey}', () => {
    describe('when valid arguments are provided', () => {
      it('returns expected result', async () => {
        const tool = ${connectorName}ConnectorConfig.tools.${toolKey} as MCPToolDefinition;
        const mockContext = createMockConnectorContext({
          credentials: { apiKey: 'test-key' },
        });

        const actual = await tool.handler({ id: 'test-id' }, mockContext);

        expect(actual).toContain('test-id');
      });
    });

    describe('when API request fails', () => {
      it('returns error message', async () => {
        const tool = ${connectorName}ConnectorConfig.tools.${toolKey} as MCPToolDefinition;
        const mockContext = createMockConnectorContext({
          credentials: { apiKey: 'invalid-key' },
        });

        const actual = await tool.handler({ id: 'test-id' }, mockContext);

        expect(actual).toContain('Failed to');
      });
    });
  });`;
      })
      .join('\n\n');

    return `import { describe, expect, it } from "vitest";
import type { MCPToolDefinition } from "@stackone/mcp-config-types";
import { createMockConnectorContext } from "../__mocks__/context";
import { ${connectorName}ConnectorConfig } from "./${template.key}";

describe("#${connectorName}Connector", () => {
${testCases}
});
`;
  }

  /**
   * Analyzes existing code patterns to provide recommendations
   */
  static analyzeCodePatterns(code: string): CodeAnalysisResult {
    const patterns: string[] = [];
    const imports: string[] = [];
    const interfaces: string[] = [];
    const recommendations: string[] = [];

    // Extract imports
    const importMatches = code.match(/import.*from.*['"]\S+['"]/g);
    if (importMatches) {
      imports.push(...importMatches);
    }

    // Extract interfaces
    const interfaceMatches = code.match(/interface\s+\w+\s*{[^}]*}/g);
    if (interfaceMatches) {
      interfaces.push(...interfaceMatches);
    }

    // Identify patterns
    if (code.includes('mcpConnectorConfig')) {
      patterns.push('MCP Connector Configuration Pattern');
    }
    if (code.includes('z.object') || code.includes("from 'zod'")) {
      patterns.push('Zod Schema Validation');
    }
    if (code.includes('async') && code.includes('await')) {
      patterns.push('Async/Await Pattern');
    }
    if (code.includes('try') && code.includes('catch')) {
      patterns.push('Error Handling Pattern');
    }

    // Generate recommendations
    if (!code.includes('try/catch')) {
      recommendations.push('Add error handling with try/catch blocks');
    }
    if (!code.includes('z.object')) {
      recommendations.push('Use Zod schemas for input validation');
    }
    if (!code.includes('describe(')) {
      recommendations.push('Add comprehensive JSDoc descriptions');
    }

    return { patterns, imports, interfaces, recommendations };
  }
}

export const MCPCreatorConnectorConfig = mcpConnectorConfig({
  name: 'MCP Creator',
  key: 'mcp-creator',
  version: '1.0.0',
  logo: 'https://stackone-logos.com/api/stackone/filled/svg',
  credentials: z.object({}),
  setup: z.object({}),
  examplePrompt:
    'Help me create a new MCP connector for Slack, generate the boilerplate code, analyze existing patterns, and set up the project structure following best practices.',
  tools: (tool) => ({
    GENERATE_CONNECTOR_TEMPLATE: tool({
      name: 'generate_connector_template',
      description:
        'Generate a basic MCP connector template with specified tools and authentication type',
      schema: z.object({
        name: z.string().describe('Name of the connector (e.g., "Slack", "GitHub")'),
        description: z.string().describe('Description of what the connector does'),
        apiType: z
          .enum(['rest-api', 'oauth', 'basic-auth', 'none'])
          .describe('Type of authentication required'),
        tools: z
          .array(z.string())
          .describe(
            'List of tool names to generate (e.g., ["Send Message", "Get Users"])'
          ),
      }),
      handler: async (args, _context) => {
        try {
          const template = MCPCreatorHelper.generateConnectorTemplate(
            args.name,
            args.description,
            args.apiType,
            args.tools
          );

          return JSON.stringify(template, null, 2);
        } catch (error) {
          return `Failed to generate connector template: ${error instanceof Error ? error.message : String(error)}`;
        }
      },
    }),

    GENERATE_CONNECTOR_CODE: tool({
      name: 'generate_connector_code',
      description: 'Generate complete MCP connector TypeScript code from a template',
      schema: z.object({
        template: z
          .string()
          .describe(
            'JSON string of the connector template from generate_connector_template'
          ),
      }),
      handler: async (args, _context) => {
        try {
          const template: MCPConnectorTemplate = JSON.parse(args.template);
          const code = MCPCreatorHelper.generateConnectorFile(template);
          return code;
        } catch (error) {
          return `Failed to generate connector code: ${error instanceof Error ? error.message : String(error)}`;
        }
      },
    }),

    GENERATE_TEST_CODE: tool({
      name: 'generate_test_code',
      description:
        'Generate comprehensive test file following repository testing patterns',
      schema: z.object({
        template: z.string().describe('JSON string of the connector template'),
      }),
      handler: async (args, _context) => {
        try {
          const template: MCPConnectorTemplate = JSON.parse(args.template);
          const testCode = MCPCreatorHelper.generateTestFile(template);
          return testCode;
        } catch (error) {
          return `Failed to generate test code: ${error instanceof Error ? error.message : String(error)}`;
        }
      },
    }),

    ANALYZE_CODE_PATTERNS: tool({
      name: 'analyze_code_patterns',
      description:
        'Analyze existing code to identify patterns, imports, and provide recommendations',
      schema: z.object({
        code: z.string().describe('TypeScript code to analyze'),
      }),
      handler: async (args, _context) => {
        try {
          const analysis = MCPCreatorHelper.analyzeCodePatterns(args.code);
          return JSON.stringify(analysis, null, 2);
        } catch (error) {
          return `Failed to analyze code patterns: ${error instanceof Error ? error.message : String(error)}`;
        }
      },
    }),

    GET_CONNECTOR_BEST_PRACTICES: tool({
      name: 'get_connector_best_practices',
      description:
        'Get comprehensive best practices for building MCP connectors based on repository patterns',
      schema: z.object({}),
      handler: async (_args, _context) => {
        const bestPractices = {
          structure: [
            'Use mcpConnectorConfig function to create connector configuration',
            'Export the config as a named export ending with "ConnectorConfig"',
            'Keep the connector fully self-contained in a single file',
            'Use TypeScript with strict typing',
          ],
          authentication: [
            'Use Zod schemas for credential validation',
            'Support common auth patterns: API keys, OAuth, Basic Auth',
            'Include clear descriptions for all credential fields',
            'Use environment-specific configurations when needed',
          ],
          tools: [
            'Each tool should have a clear, descriptive name',
            'Use Zod schemas for input validation',
            'Include comprehensive descriptions for all parameters',
            'Implement proper error handling with try/catch blocks',
            'Return JSON.stringify() for complex objects',
            'Return descriptive error messages on failure',
          ],
          api_calls: [
            'Use native fetch() for HTTP requests - avoid external libraries',
            'Include proper headers (Content-Type, Authorization)',
            'Check response.ok before processing',
            'Handle different HTTP status codes appropriately',
            'Use async/await pattern consistently',
          ],
          testing: [
            'Write tests for every tool using vitest',
            'Test happy path, error cases, and edge cases',
            'Use createMockConnectorContext for mocking',
            'Follow the repository naming conventions for describes and its',
            'Each connector should have a single .spec.ts file',
            'Use MSW for mocking HTTP requests, not vi.mock()',
          ],
          development: [
            'Use bun as the package manager',
            'Run linting and type checking before commits',
            'Follow the existing code style and conventions',
            'Use modern JavaScript features compatible with Node, Bun, and Cloudflare Workers',
            'Avoid niche features that may not be universally supported',
          ],
        };

        return JSON.stringify(bestPractices, null, 2);
      },
    }),

    GENERATE_PROJECT_SETUP: tool({
      name: 'generate_project_setup',
      description:
        'Generate project setup instructions and development workflow for new MCP connectors',
      schema: z.object({
        connectorName: z.string().describe('Name of the connector being created'),
      }),
      handler: async (args, _context) => {
        const setupInstructions = {
          repository_setup: [
            '1. Clone the mcp-connectors repository',
            '2. Run `bun install` to install dependencies',
            '3. Create your connector file in packages/mcp-connectors/src/connectors/',
            '4. Add your connector to the exports in packages/mcp-connectors/src/index.ts',
          ],
          development_workflow: [
            '1. Start with `bun start --connector test` to verify setup',
            '2. Create your connector using the generated template',
            '3. Test locally with `bun start --connector your-connector --credentials \'{"apiKey":"test"}\'`',
            '4. Write comprehensive tests in a .spec.ts file',
            '5. Run `bun test` to execute tests',
            '6. Run `bun run build` to check for TypeScript errors',
            '7. Run `bun run lint` to check code style',
          ],
          file_structure: {
            connector_file: `packages/mcp-connectors/src/connectors/${args.connectorName.toLowerCase()}.ts`,
            test_file: `packages/mcp-connectors/src/connectors/${args.connectorName.toLowerCase()}.spec.ts`,
            export_location: 'packages/mcp-connectors/src/index.ts',
          },
          commands: {
            install: 'bun install',
            test_connector: `bun start --connector ${args.connectorName.toLowerCase()}`,
            run_tests: 'bun test',
            build: 'bun run build',
            lint: 'bun run lint',
          },
        };

        return JSON.stringify(setupInstructions, null, 2);
      },
    }),

    GET_CLAUDE_AGENT_PATTERNS: tool({
      name: 'get_claude_agent_patterns',
      description:
        'Get patterns and best practices that Claude agents use when working on GitHub issues',
      schema: z.object({}),
      handler: async (_args, _context) => {
        const claudePatterns = {
          planning_patterns: [
            'Break complex tasks into structured todo lists',
            'Mark tasks as in_progress when starting work',
            'Mark tasks as completed immediately upon completion',
            'Add new subtasks as they are discovered during implementation',
            'Update progress in GitHub comments to maintain transparency',
          ],
          code_analysis_patterns: [
            'Read existing code patterns before implementing new features',
            'Use search tools extensively to understand codebase structure',
            'Follow existing naming conventions and code style',
            'Look for similar implementations to maintain consistency',
            'Identify and reuse existing utilities and libraries',
          ],
          implementation_patterns: [
            'Start with the simplest working implementation',
            'Add comprehensive error handling and validation',
            'Use TypeScript for strong typing and better developer experience',
            'Write clear, self-documenting code with good variable names',
            'Include JSDoc comments for complex functions',
          ],
          testing_patterns: [
            'Write tests that cover happy path, error cases, and edge cases',
            'Use descriptive test names that explain the expected behavior',
            'Mock external dependencies to ensure isolated testing',
            'Test both successful operations and failure scenarios',
            'Ensure tests can run independently without shared state',
          ],
          git_workflow_patterns: [
            'Create descriptive commit messages that explain the "why"',
            'Include co-authored-by trailers when working with users',
            'Stage and commit related changes together',
            'Push changes to remote branches for collaboration',
            'Provide PR URLs with pre-filled titles and descriptions',
          ],
          communication_patterns: [
            'Provide clear progress updates in GitHub comments',
            'Reference specific code locations with file:line_number format',
            'Explain complex decisions and trade-offs',
            'Ask for clarification when requirements are ambiguous',
            'Document any assumptions made during implementation',
          ],
        };

        return JSON.stringify(claudePatterns, null, 2);
      },
    }),
  }),
});
